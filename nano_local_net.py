#!/usr/bin/env python

import requests
import json
import logging
import os
import sys
from nano_rpc import Api
import argparse
import math
import time
import tomli
import tomli_w
import yaml

# * Create (this will create the one time resources that need creating)
# * Start (this will start the nodes)
# * InitialBlocks (create an initial ledger structure common to all, epoch1 and 2 and canary blocks, etc)
# * RunTest
# * Stop (stop the nodes but do not destroy anything)
# * Destroy (destroy all autogenerated resources, so that we can start from virgin state next time)
# And have a config file to describe options?
# And use shell scripts for doing some of that directory/file manipulation and commands executions that are cumbersome in python?

#built from 
_config_path = "./nano_local_config.toml"
_default_compose_path = "./config/default_docker-compose.yml"
_node_path = {}
_config_dict = {} 
_compose_dict = {}


def create_node_folders(node_name):
    global _node_path
    commands = [ "mkdir -p nano_nodes",
                f"cd nano_nodes && mkdir -p {node_name}",
                f"cd nano_nodes/{node_name} && mkdir -p NanoTest" ]

    for command in commands:
        os.system(command)

    _node_path[node_name] = {"data_path" :       f"./nano_nodes/{node_name}/NanoTest",
                            "config_node_path" : f"./nano_nodes/{node_name}/NanoTest/config-node.toml",
                            "config_rpc_path"  : f"./nano_nodes/{node_name}/NanoTest/config-rpc.toml"}


def create_nano_node():
    #Create config files
    #reate docker-comose entry
    pass



def docker_add_account(container,command, genesis_key = None):
    #command = nano-workspace/build/nano_node --network test ##for custom biulds using dsiganos/nano-workspace
    #comand = /usr/bin/nano_node ##when using existing docker-tags from nanocurrency/nano-test

    wallet_create =    f"docker exec -it {container} {command} --wallet_create"
    wallet_list =      f"docker exec -it {container} {command} --wallet_list | awk 'FNR == 1 {{print $3}}' | tr -d '\r'"
    account_create =   f"docker exec -it {container} {command} --account_create --wallet={wallet}"
    wallet_add_adhoc = f"docker exec -it {container} {command} --wallet_add_adhoc --wallet={wallet} --key={genesis_key}"
    account_get =      f"docker exec -it {container} {command} --wallet_list | awk 'FNR == 2 {{print $1}}' | tr -d '\r')"

    os.system(wallet_create)
    wallet = os.popen(wallet_list).read()
    if genesis_key != None : os.system(account_create)
    if genesis_key == None : os.system(wallet_add_adhoc)
    account = os.popen(account_get)

    return {"wallet" : wallet, "account" : account}


def write_toml(path, content):
    with open(path, "wb") as f:    
        tomli_w.dump(content, f)

def read_toml(path):
    try:
        with open(path, "rb") as f:
            toml_dict = tomli.load(f)
            return toml_dict
    except tomli.TOMLDecodeError as e:
        logging.error("Invalid config file! \n {}".format(str(e)))

def read_yaml(path):
    with open(path, 'r') as f:
        return yaml.safe_load(f)

def write_yaml(path, content):
    with open(path, 'wb', encoding='utf8') as f:
        yaml.dump(content, f, default_flow_style=False)

def append_node_to_docker_compose(node_name):

    _compose_dict


def parse_nano_local_config():
    pass


def write_config_node(node_name):
    config_node = get_config_from_path(node_name, "config_node_path")
    if config_node is None :
        logging.warn("No config-node.toml found. Use minimal version")
        config_node = {"rpc" : {"enable" : True} , 
                       "node" : {"allow_local_peers" : True, "enable_voting" : True}}

    config_node["node"]["preconfigured_peers"] = get_preconfigured_peers()

    if not node_name in _node_path : #should not happen
        logging.warn(f"Environment created form {node_name}")
        create_node_folders(node_name)    

    write_toml(_node_path[node_name]["config_node_path"], config_node)    
 
def write_config_rpc(node_name):
    config_rpc = get_config_from_path(node_name, "config_rpc_path")
    if config_rpc is None :
        logging.warn("No config-node.toml found. Use minimal version")
        config_rpc = {"enable_control" : True, "enable_sign_hash" : True}
    
    if not node_name in _node_path : #should not happen
        logging.warn(f"Environment created form {node_name}")
        create_node_folders(node_name)    

    write_toml(_node_path[node_name]["config_rpc_path"], config_rpc)


def get_config_from_path(node_name, config_path_key):
    #returns None if no path is found
    config_dict_l = None
    representatives_config = value_in_dict_array(_config_dict["representatives"]["nodes"], node_name)    
    #if individual config is found, use that
    if representatives_config["found"] == True:        
        if config_path_key in representatives_config["dict"]:
            config_dict_l = read_toml(representatives_config["dict"][config_path_key])
    #else use shared config
    elif config_path_key in _config_dict["representatives"]:
        config_dict_l = read_toml(_config_dict["representatives"][config_path_key])
    else:
        pass #return None  
    return config_dict_l
   
    
def get_preconfigured_peers():
    perconfigures_peers = []
    for node in _config_dict["representatives"]["nodes"]:
        perconfigures_peers.append(node["name"])    
    return perconfigures_peers    


def value_in_dict_array(dict_array, value_l) :
    for dict in dict_array :
        dict_found = value_in_dict(dict, value_l)
        if dict_found["found"] : return dict_found
    return {"found" : False, "dict" : None}


def value_in_dict(dict, value_l):
    for key,value in dict.items():
        if value==value_l:
            return {"found" : True, "dict" : dict}
    return {"found" : False, "dict" : None}

def prepare_node_env(node_name):
    create_node_folders(node_name)
    write_config_node(node_name)
    write_config_rpc(node_name)


def create_network_nodes(): 
    prepare_node_env("nano_private_genesis")



def main():
    global _config_dict, _compose_dict
    _config_dict = read_toml(_config_path)
    _compose_dict = read_yaml(_default_compose_path)
    
    # create_node_environment("nano_private_genesis")
    # write_config_node("nano_private_genesis")
    # write_config_rpc("nano_private_genesis")

    yml = read_yaml("./config/default_docker-compose.yml")
    # yml["services"]["new_docker"] = yml["services"]["default_docker"]

    default_build = yml["services"]["default_build"]
    default_docker = yml["services"]["default_docker"]

    yml["services"].pop("default_docker", None)
    yml["services"].pop("default_build", None)

    host_port_rpc = 45001
    host_port_ws = 47001
    default_build["ports"] = [f'{host_port_rpc}:17076', f'{host_port_ws}:17078']

  

    #create all nodes



    

    #spin up genesis and send epochs and carnary

    # for node in _config_dict["representatives"]["nodes"]:
    #     #write config


if __name__=="__main__":
    main()

# for i in range(0, length(representatives) ): 
#         if i == 0 : 
#             pr_name  = "nano_local_genesis" 
#         else  :
#             pr_name = "nano_local_pr{}".format(i)
#         preconfigured_peers = add_preconfigured_peers(preconfigured_peers,pr_name)
#         os.system("cd reps && mkdir -p {}".format(pr_name))
#         if i <= args.pr_quorum : 
#             if i == 0 : #genesis
#                 pr_names[pr_name] = {"pr_type" : "genesis", 
#                                      "genesis_key" : "12C91837C846F875F56F67CD83040A832CFC0F131AF3DFF9E502C0D43F5D2D15", 
#                                      "peering_port": "4400{}".format(i), 
#                                      "rpc_port" : "4500{}".format(i)}
#             else:
#                 pr_names[pr_name] = {"pr_type" : "pr_quorum", 
#                                      "genesis_key" : None, 
#                                      "peering_port": "4400{}".format(i),
#                                      "rpc_port" : "4500{}".format(i)}            
#         else :
#             pr_names[pr_name] = {"pr_type" : "pr_non_quorum", "genesis_key" : None, "peering_port": "4400{}".format(i), "rpc_port" : "4500{}".format(i)}
  



dta = {
    "genesis_pkey": "12C91837C846F875F56F67CD83040A832CFC0F131AF3DFF9E502C0D43F5D2D15",
    "canary_pkey": "FB4E458CB13508353C5B2574B82F1D1D61367F61E88707F773F068FF90050BEE",
    "epoch_count": 2,
    "burn_amount": "200000000000000000000000000000000000000",
    "NANO_TEST_EPOCH_1": "0xfff00000000000000",
    "NANO_TEST_EPOCH_2": "0xfff0000000000000",
    "NANO_TEST_EPOCH_2_RECV": "0xfff0000000000000",
    "NANO_TEST_MAGIC_NUMBER": "LC",
    "representatives": {
        "config_node_path": "./config-node.toml",
        "config_rpc_path": "./config-rpc.toml",
        "docker_tag": "V23.0",
        "nodes": [
            {
                "name": "PR_1",
                "seed": "00001837C846F875F56F67CD83040A832CFC0F131AF3DFF9E502C0D43F5D0000",
                "balance": "43000000000000000000000000000000000000",
                "config_node_path": "",
                "config_rpc_path": "",
                "docker_tag": "V22.1"
            },
            {
                "name": "PR_2",
                "seed": "00001837C846F875F56F67CD83040A832CFC0F131AF3DFF9E502C0D43F5D0001",
                "vote_weight_percent": 35
            },
            {
                "name": "low_weight_1",
                "seed": "00001837C846F875F56F67CD83040A832CFC0F131AF3DFF9E502C0D43F5D0001",
                "vote_weight_percent": 0.05
            }
        ],
        "docker": {
            "dockerfile_path": "./Dockerfile",
            "args": [
                "TAG=V23.0"
            ],
            "command": "./nano-workspace/build/nano_node --daemon --network test"
        }
    }
}

